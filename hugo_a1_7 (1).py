# -*- coding: utf-8 -*-
"""HUGO A1_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GtZibcnCWoD-RNc4dTiq6PD9ZUP-SfJE
"""

import numpy as np
import matplotlib.pyplot as plt

# Defina a função Rectified Linear Unit (ReLU)
def ReLU(preactivation):
  # TODO: utilize a implementação do notebook anterior
  return np.clip(preactivation, 0, None)

# Testando a função ReLU com uma matriz de pré-ativação
preactivation = np.array([-2, -1, 0, 1, 2])
activation = ReLU(preactivation)

# Exibe a saída da função de ativação
print("Saída da Ativação:", activation)

# Definir uma rede neural rasa com uma entrada, uma saída e três unidades ocultas
def shallow_1_1_3(x, activation_fn, phi_0, phi_1, phi_2, phi_3, theta_10, theta_11, theta_20, theta_21, theta_30, theta_31):
  # TODO Substituir as linhas abaixo para calcular as três linhas iniciais
  # (figura 3.3a-c) a partir dos parâmetros theta. Estas são as pré-ativações
  pre_1 = theta_10 + theta_11 * x
  pre_2 = theta_20 + theta_21 * x
  pre_3 = theta_30 + theta_31 * x

  # Passar esses valores pela função ReLU para calcular as ativações como na
  # figura 3.3 d-f
  act_1 = activation_fn(pre_1)
  act_2 = activation_fn(pre_2)
  act_3 = activation_fn(pre_3)

  # TODO Substituir o código abaixo para ponderar as ativações usando phi1, phi2 e phi3
  # Para criar o equivalente à figura 3.3 g-i
  w_act_1 = phi_1 * act_1
  w_act_2 = phi_2 * act_2
  w_act_3 = phi_3 * act_3

  # TODO Substituir o código abaixo para combinar as ativações ponderadas e adicionar
  # phi_0 para criar a saída como na figura 3.3 j
  y = phi_0 + w_act_1 + w_act_2 + w_act_3

  # Retornar tudo o que calculamos
  return y

# # Plote a rede neural rasa. Vamos assumir que a entrada está no intervalo [-1,1] e a saída [-1,1]
def plot_neural(x, y):
  fig, ax = plt.subplots()
  ax.plot(x.T,y.T)
  ax.set_xlabel('Entrada'); ax.set_ylabel('Saída')
  ax.set_xlim([-1,1]);ax.set_ylim([-1,1])
  ax.set_aspect(1.0)
  plt.show()

"""Vamos definir uma rede. Vamos apenas considerar as entradas e saídas no intervalo [-1,1]."""

# Agora vamos definir alguns parâmetros e executar a primeira rede neural
n1_theta_10 = 0.0   ; n1_theta_11 = -1.0
n1_theta_20 = 0     ; n1_theta_21 = 1.0
n1_theta_30 = -0.67 ; n1_theta_31 =  1.0
n1_phi_0 = 1.0; n1_phi_1 = -2.0; n1_phi_2 = -3.0; n1_phi_3 = 9.3

# Defina uma faixa de valores de entrada
n1_in = np.arange(-1,1,0.01).reshape([1,-1])

# Rodamos a rede neural para cada um desses valores de entrada
n1_out, *_ = shallow_1_1_3(n1_in, ReLU, n1_phi_0, n1_phi_1, n1_phi_2, n1_phi_3, n1_theta_10, n1_theta_11, n1_theta_20, n1_theta_21, n1_theta_30, n1_theta_31)
# E então plotamos
plot_neural(n1_in, n1_out)

"""Agora vamos definir a mesma rede neural, mas desta vez, vamos usar a forma matricial. Quando você fizer isso corretamente, ele desenhará o mesmo gráfico que acima."""

beta_0 = np.zeros((3,1))
Omega_0 = np.zeros((3,1))
beta_1 = np.zeros((1,1))
Omega_1 = np.zeros((1,3))

# TODO Preencha os valores das matrizes beta e Omega com os parâmetros n1_theta e n1_phi que definem a rede acima
# !!! OBSERVE QUE AS MATRIZES SÃO CONVENCIONALMENTE INDEXADAS COM a_11 NO CANTO SUPERIOR ESQUERDO, MAS NDARRAYS COMEÇAM EM [0,0]
# Para começar, eu já preenchi algumas:

#primeiro
beta_0[0,0] = n1_theta_10
beta_0[1,0] = n1_theta_20
beta_0[2,0] = n1_theta_30

#segundo
beta_1[0,0] = n1_phi_0

#terceiro
Omega_0[0,0] = n1_theta_11
Omega_0[1,0] = n1_theta_21
Omega_0[2,0] = n1_theta_31

#quarto
Omega_1[0,0] = n1_phi_1
Omega_1[0,1] = n1_phi_2
Omega_1[0,2] = n1_phi_3


print(beta_0)
print('-------')
print(Omega_0)

# Certifique-se de que a matriz de dados de entrada tenha entradas diferentes em suas colunas
n_data = n1_in.size
n_dim_in = 1
n1_in_mat = np.reshape(n1_in,(n_dim_in,n_data))

# Isso executa a rede para TODAS as entradas, x de uma vez, para que possamos desenhar o gráfico
h1 = ReLU(np.matmul(beta_0,np.ones((1,n_data))) + np.matmul(Omega_0,n1_in_mat))
n1_out = np.matmul(beta_1,np.ones((1,n_data))) + np.matmul(Omega_1,h1)

# Desenhe a rede e verifique se ela se parece com o caso não matricial
plot_neural(n1_in, n1_out)

"""`mesmo gráfico check` ✅

Agora vamos alimentar a saída da primeira rede na segunda.
"""

# Agora vamos definir alguns parâmetros e executar a segunda rede neural
n2_theta_10 =  -0.6 ; n2_theta_11 = -1.0
n2_theta_20 =  0.2  ; n2_theta_21 = 1.0
n2_theta_30 =  -0.5  ; n2_theta_31 =  1.0
n2_phi_0 = 0.5; n2_phi_1 = -1.0; n2_phi_2 = -1.5; n2_phi_3 = 2.0

# Defina uma faixa de valores de entrada
n2_in = np.arange(-1,1,0.01)

# Rodamos a segunda rede neural na saída da primeira rede
n2_out, *_ = \
    shallow_1_1_3(n1_out, ReLU, n2_phi_0, n2_phi_1, n2_phi_2, n2_phi_3, n2_theta_10, n2_theta_11, n2_theta_20, n2_theta_21, n2_theta_30, n2_theta_31)
# E então plotamos
plot_neural(n1_in, n2_out)

beta_0 = np.zeros((3,1))
Omega_0 = np.zeros((3,1))
beta_1 = np.zeros((3,1))
Omega_1 = np.zeros((3,3))
beta_2 = np.zeros((1,1))
Omega_2 = np.zeros((1,3))

# TODO Preencha os valores das matrizes beta e Omega para os parâmetros n1_theta, n1_phi, n2_theta e n2_phi
# que definem a composição das duas redes acima (veja eqn 4.5 para Omega1 e beta1, embora em notação diferente)
# !!! OBSERVE QUE AS MATRIZES SÃO CONVENCIONALMENTE INDEXADAS COM a_11 NO CANTO SUPERIOR ESQUERDO, MAS NDARRAYS COMEÇAM EM [0,0] ENTÃO TUDO ESTÁ DESLOCADO
# Para começar, eu já preenchi alguns:
beta_0[0,0] = n1_theta_10
Omega_0[0,0] = n1_theta_11

#primeiro
beta_0[0,0] = n1_theta_10
beta_0[1,0] = n1_theta_20
beta_0[2,0] = n1_theta_30

#segundo
beta_1[0,0] = n2_theta_10
beta_1[1,0] = n2_theta_20
beta_1[2,0] = n2_theta_30

beta_2[0,0] = n2_phi_0

#terceiro
Omega_0[0,0] = n1_theta_11
Omega_0[1,0] = n1_theta_21
Omega_0[2,0] = n1_theta_31

#quarto
Omega_1[0,0] = n1_phi_1
Omega_1[0,1] = n1_phi_2
Omega_1[0,2] = n1_phi_3
Omega_1[1,0] = n1_phi_1
Omega_1[1,1] = n1_phi_2
Omega_1[1,2] = n1_phi_3
Omega_1[2,0] = n1_phi_1
Omega_1[2,1] = n1_phi_2
Omega_1[2,2] = n1_phi_3

Omega_2[0,0] = n2_phi_1
Omega_2[0,1] = n2_phi_2
Omega_2[0,2] = n2_phi_3

# Certifique-se de que a matriz de dados de entrada tenha entradas diferentes em suas colunas
n_data = n1_in.size
n_dim_in = 1
n1_in_mat = np.reshape(n1_in,(n_dim_in,n_data))

# Isso executa a rede para TODAS as entradas, x de uma vez, para que possamos desenhar o gráfico (portanto, termo np.ones extra)
h1 = ReLU(np.matmul(beta_0,np.ones((1,n_data))) + np.matmul(Omega_0,n1_in_mat))
h2 = ReLU(np.matmul(beta_1,np.ones((1,n_data))) + np.matmul(Omega_1,h1))
n1_out = np.matmul(beta_2,np.ones((1,n_data))) + np.matmul(Omega_2,h2)

# Desenhe a rede e verifique se ela se parece com a versão não matricial
plot_neural(n1_in, n1_out)

"""Agora vamos criar uma rede profunda com 3 camadas ocultas. Ela terá $D_i=4$ entradas, $D_1=5$ neurônios na primeira camada, $D_2=2$ neurônios na segunda camada e $D_3=4$ neurônios na terceira camada, e $D_o = 1$ saída. Consulte a figura 4.6 e as equações 4.15 para orientação.

"""

# define tamanhos
D_i=4; D_1=5; D_2=2; D_3=4; D_o=1
# Vamos escolher as entradas e parâmetros dessa rede aleatoriamente usando np.random.normal
# Por exemplo, vamos definir a entrada usando
n_data = 4;
x = np.random.normal(size=(D_i, n_data))
# TODO inicialize os parâmetros aleatoriamente com os tamanhos corretos
# Substitua as linhas abaixo
beta_0 = np.random.normal(size=(1,1))
Omega_0 = np.random.normal(size=(1,1))
beta_1 = np.random.normal(size=(1,1))
Omega_1 = np.random.normal(size=(1,1))
beta_2 = np.random.normal(size=(1,1))
Omega_2 = np.random.normal(size=(1,1))
beta_3 = np.random.normal(size=(1,1))
Omega_3 = np.random.normal(size=(1,1))


# Se você definir os parâmetros com os tamanhos corretos, o código a seguir roda sem erros
h1 = ReLU(np.matmul(beta_0,np.ones((1,n_data))) + np.matmul(Omega_0,x));
h2 = ReLU(np.matmul(beta_1,np.ones((1,n_data))) + np.matmul(Omega_1,h1));
h3 = ReLU(np.matmul(beta_2,np.ones((1,n_data))) + np.matmul(Omega_2,h2));
y = np.matmul(beta_3,np.ones((1,n_data))) + np.matmul(Omega_3,h3)

if h1.shape[0] != D_1 or h1.shape[1] != n_data:
  print("h1 is wrong shape")
if h2.shape[0] != D_2 or h1.shape[1] != n_data:
  print("h2 is wrong shape")
if h3.shape[0] != D_3 or h1.shape[1] != n_data:
  print("h3 is wrong shape")
if y.shape[0] != D_o or h1.shape[1] != n_data:
  print("Output is wrong shape")

# Imprima as entradas e saídas
print("Pontos de dados de entrada")
print(x)
print ("Pontos de dados de saída")
print(y)